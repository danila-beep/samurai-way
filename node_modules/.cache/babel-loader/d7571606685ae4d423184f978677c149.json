{"ast":null,"code":"import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';\nimport locales from './locales';\nexport class MixedType {\n  constructor(name) {\n    this.required = false;\n    this.requiredMessage = '';\n    this.trim = false;\n    this.emptyAllowed = false;\n    this.rules = [];\n    this.priorityRules = [];\n    this.typeName = name;\n    this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);\n  }\n\n  setSchemaOptions(schemaSpec, value) {\n    this.schemaSpec = schemaSpec;\n    this.value = value;\n  }\n\n  check() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return {\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      };\n    }\n\n    const validator = createValidator(data, fieldName);\n    const checkStatus = validator(value, this.priorityRules);\n\n    if (checkStatus) {\n      return checkStatus;\n    }\n\n    if (!this.required && isEmpty(value)) {\n      return {\n        hasError: false\n      };\n    }\n\n    return validator(value, this.rules) || {\n      hasError: false\n    };\n  }\n\n  checkAsync() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    let fieldName = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return Promise.resolve({\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, {\n          name: fieldName\n        })\n      });\n    }\n\n    const validator = createValidatorAsync(data, fieldName);\n    return new Promise(resolve => validator(value, this.priorityRules).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n    }).then(() => {\n      if (!this.required && isEmpty(value)) {\n        resolve({\n          hasError: false\n        });\n      }\n    }).then(() => validator(value, this.rules)).then(checkStatus => {\n      if (checkStatus) {\n        resolve(checkStatus);\n      }\n\n      resolve({\n        hasError: false\n      });\n    }));\n  }\n\n  pushRule(rule) {\n    var _a, _b;\n\n    const {\n      onValid,\n      errorMessage,\n      priority,\n      params\n    } = rule;\n    const nextRule = {\n      onValid,\n      params,\n      isAsync: rule.isAsync,\n      errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)\n    };\n\n    if (priority) {\n      this.priorityRules.push(nextRule);\n    } else {\n      this.rules.push(nextRule);\n    }\n  }\n\n  addRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n\n  addAsyncRule(onValid, errorMessage, priority) {\n    this.pushRule({\n      onValid,\n      isAsync: true,\n      errorMessage,\n      priority\n    });\n    return this;\n  }\n\n  isRequired() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequired;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n\n  isRequiredOrEmpty() {\n    let errorMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.locale.isRequiredOrEmpty;\n    let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.required = true;\n    this.trim = trim;\n    this.emptyAllowed = true;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  /**\n   * Define data verification rules based on conditions.\n   * @param validator\n   * @example\n   * MixedType().when(schema => {\n   *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n   * });\n   */\n\n\n  when(condition) {\n    this.addRule((value, data, filedName) => {\n      return condition(this.schemaSpec).check(value, data, filedName);\n    }, undefined, true);\n    return this;\n  }\n\n}\nexport default function getMixedType() {\n  return new MixedType();\n}","map":{"version":3,"mappings":"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","names":["checkRequired","createValidator","createValidatorAsync","isEmpty","formatErrorMessage","locales","MixedType","constructor","name","typeName","locale","Object","assign","mixed","setSchemaOptions","schemaSpec","value","check","data","fieldName","required","trim","emptyAllowed","hasError","errorMessage","requiredMessage","validator","checkStatus","priorityRules","rules","checkAsync","Promise","resolve","then","pushRule","rule","onValid","priority","params","nextRule","isAsync","_a","_b","push","addRule","addAsyncRule","isRequired","isRequiredOrEmpty","when","condition","filedName","undefined","getMixedType"],"sources":["/Users/danilnagovicyn/Desktop/reactprojects/Incubator/Samurai_way/samurai-way/node_modules/schema-typed/src/MixedType.ts"],"sourcesContent":["import {\n  SchemaDeclaration,\n  CheckResult,\n  ValidCallbackType,\n  AsyncValidCallbackType,\n  RuleType,\n  ErrorMessageType,\n  TypeName\n} from './types';\nimport {\n  checkRequired,\n  createValidator,\n  createValidatorAsync,\n  isEmpty,\n  formatErrorMessage\n} from './utils';\nimport locales, { MixedTypeLocale } from './locales';\n\nexport class MixedType<ValueType = any, DataType = any, E = ErrorMessageType, L = any> {\n  readonly typeName?: string;\n  protected required = false;\n  protected requiredMessage: E | string = '';\n  protected trim = false;\n  protected emptyAllowed = false;\n  protected rules: RuleType<ValueType, DataType, E | string>[] = [];\n  protected priorityRules: RuleType<ValueType, DataType, E | string>[] = [];\n\n  schemaSpec: SchemaDeclaration<DataType, E>;\n  value: any;\n  locale: L & MixedTypeLocale;\n\n  constructor(name?: TypeName) {\n    this.typeName = name;\n    this.locale = Object.assign(name ? locales[name] : {}, locales.mixed) as L & MixedTypeLocale;\n  }\n\n  setSchemaOptions(schemaSpec: SchemaDeclaration<DataType, E>, value: any) {\n    this.schemaSpec = schemaSpec;\n    this.value = value;\n  }\n\n  check(value: ValueType = this.value, data?: DataType, fieldName?: string | string[]) {\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return {\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n      };\n    }\n\n    const validator = createValidator<ValueType, DataType, E | string>(data, fieldName);\n\n    const checkStatus = validator(value, this.priorityRules);\n\n    if (checkStatus) {\n      return checkStatus;\n    }\n\n    if (!this.required && isEmpty(value)) {\n      return { hasError: false };\n    }\n\n    return validator(value, this.rules) || { hasError: false };\n  }\n\n  checkAsync(\n    value: ValueType = this.value,\n    data?: DataType,\n    fieldName?: string | string[]\n  ): Promise<CheckResult<E | string>> {\n    if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {\n      return Promise.resolve({\n        hasError: true,\n        errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })\n      });\n    }\n\n    const validator = createValidatorAsync<ValueType, DataType, E | string>(data, fieldName);\n\n    return new Promise(resolve =>\n      validator(value, this.priorityRules)\n        .then((checkStatus: CheckResult<E | string> | void | null) => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n        })\n        .then(() => {\n          if (!this.required && isEmpty(value)) {\n            resolve({ hasError: false });\n          }\n        })\n        .then(() => validator(value, this.rules))\n        .then((checkStatus: CheckResult<E | string> | void | null) => {\n          if (checkStatus) {\n            resolve(checkStatus);\n          }\n          resolve({ hasError: false });\n        })\n    );\n  }\n  protected pushRule(rule: RuleType<ValueType, DataType, E | string>) {\n    const { onValid, errorMessage, priority, params } = rule;\n    const nextRule = {\n      onValid,\n      params,\n      isAsync: rule.isAsync,\n      errorMessage: errorMessage || this.rules?.[0]?.errorMessage\n    };\n\n    if (priority) {\n      this.priorityRules.push(nextRule);\n    } else {\n      this.rules.push(nextRule);\n    }\n  }\n  addRule(\n    onValid: ValidCallbackType<ValueType, DataType, E | string>,\n    errorMessage?: E | string,\n    priority?: boolean\n  ) {\n    this.pushRule({ onValid, errorMessage, priority });\n    return this;\n  }\n  addAsyncRule(\n    onValid: AsyncValidCallbackType<ValueType, DataType, E | string>,\n    errorMessage?: E | string,\n    priority?: boolean\n  ) {\n    this.pushRule({ onValid, isAsync: true, errorMessage, priority });\n    return this;\n  }\n  isRequired(errorMessage: E | string = this.locale.isRequired, trim = true) {\n    this.required = true;\n    this.trim = trim;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n  isRequiredOrEmpty(errorMessage: E | string = this.locale.isRequiredOrEmpty, trim = true) {\n    this.required = true;\n    this.trim = trim;\n    this.emptyAllowed = true;\n    this.requiredMessage = errorMessage;\n    return this;\n  }\n\n  /**\n   * Define data verification rules based on conditions.\n   * @param validator\n   * @example\n   * MixedType().when(schema => {\n   *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);\n   * });\n   */\n  when(condition: (schemaSpec: SchemaDeclaration<DataType, E>) => MixedType) {\n    this.addRule(\n      (value, data, filedName) => {\n        return condition(this.schemaSpec).check(value, data, filedName);\n      },\n      undefined,\n      true\n    );\n    return this;\n  }\n}\n\nexport default function getMixedType<DataType = any, E = ErrorMessageType>() {\n  return new MixedType<DataType, E>();\n}\n"]},"metadata":{},"sourceType":"module"}