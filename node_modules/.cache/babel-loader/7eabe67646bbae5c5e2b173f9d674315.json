{"ast":null,"code":"export class Schema {\n  constructor(schema) {\n    this.spec = schema;\n  }\n\n  getFieldType(fieldName) {\n    var _a;\n\n    return (_a = this.spec) === null || _a === void 0 ? void 0 : _a[fieldName];\n  }\n\n  getKeys() {\n    return Object.keys(this.spec);\n  }\n\n  setSchemaOptionsForAllType(data) {\n    if (data === this.data) {\n      return;\n    }\n\n    Object.entries(this.spec).forEach(_ref => {\n      let [key, type] = _ref;\n      type.setSchemaOptions(this.spec, data === null || data === void 0 ? void 0 : data[key]);\n    });\n    this.data = data;\n  }\n\n  checkForField(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return {\n        hasError: false\n      };\n    }\n\n    return fieldChecker.check(data[fieldName], data, fieldName);\n  }\n\n  checkForFieldAsync(fieldName, data) {\n    this.setSchemaOptionsForAllType(data);\n    const fieldChecker = this.spec[fieldName];\n\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({\n        hasError: false\n      });\n    }\n\n    return fieldChecker.checkAsync(data[fieldName], data, fieldName);\n  }\n\n  check(data) {\n    const checkResult = {};\n    Object.keys(this.spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key, data);\n      }\n    });\n    return checkResult;\n  }\n\n  checkAsync(data) {\n    const checkResult = {};\n    const promises = [];\n    const keys = [];\n    Object.keys(this.spec).forEach(key => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key, data));\n    });\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n\n      return checkResult;\n    });\n  }\n\n}\nexport function SchemaModel(o) {\n  return new Schema(o);\n}\n\nSchemaModel.combine = function combine() {\n  for (var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++) {\n    specs[_key] = arguments[_key];\n  }\n\n  return new Schema(specs.map(model => model.spec).reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));\n};","map":{"version":3,"mappings":"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","names":["Schema","constructor","schema","spec","getFieldType","fieldName","_a","getKeys","Object","keys","setSchemaOptionsForAllType","data","entries","forEach","key","type","setSchemaOptions","checkForField","fieldChecker","hasError","check","checkForFieldAsync","Promise","resolve","checkAsync","checkResult","promises","push","all","then","values","i","length","SchemaModel","o","combine","specs","map","model","reduce","accumulator","currentValue","assign"],"sources":["/Users/danilnagovicyn/Desktop/reactprojects/Incubator/Samurai_way/samurai-way/node_modules/schema-typed/src/Schema.ts"],"sourcesContent":["import { SchemaDeclaration, SchemaCheckResult, CheckResult, PlainObject } from './types';\nimport { MixedType } from './MixedType';\n\nexport class Schema<DataType = any, ErrorMsgType = string> {\n  readonly spec: SchemaDeclaration<DataType, ErrorMsgType>;\n  private data: PlainObject;\n\n  constructor(schema: SchemaDeclaration<DataType, ErrorMsgType>) {\n    this.spec = schema;\n  }\n\n  getFieldType<T extends keyof DataType>(fieldName: T) {\n    return this.spec?.[fieldName];\n  }\n\n  getKeys() {\n    return Object.keys(this.spec);\n  }\n\n  setSchemaOptionsForAllType(data: PlainObject) {\n    if (data === this.data) {\n      return;\n    }\n\n    Object.entries(this.spec).forEach(([key, type]) => {\n      (type as MixedType).setSchemaOptions(this.spec as any, data?.[key]);\n    });\n\n    this.data = data;\n  }\n\n  checkForField<T extends keyof DataType>(fieldName: T, data: DataType) {\n    this.setSchemaOptionsForAllType(data);\n\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return { hasError: false };\n    }\n\n    return fieldChecker.check((data[fieldName] as unknown) as never, data, fieldName as string);\n  }\n\n  checkForFieldAsync<T extends keyof DataType>(\n    fieldName: T,\n    data: DataType\n  ): Promise<CheckResult<ErrorMsgType | string>> {\n    this.setSchemaOptionsForAllType(data);\n\n    const fieldChecker = this.spec[fieldName];\n    if (!fieldChecker) {\n      // fieldValue can be anything if no schema defined\n      return Promise.resolve({ hasError: false });\n    }\n    return fieldChecker.checkAsync(\n      (data[fieldName] as unknown) as never,\n      data,\n      fieldName as string\n    );\n  }\n\n  check<T extends keyof DataType>(data: DataType) {\n    const checkResult: PlainObject = {};\n    Object.keys(this.spec).forEach(key => {\n      if (typeof data === 'object') {\n        checkResult[key] = this.checkForField(key as T, data);\n      }\n    });\n\n    return checkResult as SchemaCheckResult<DataType, ErrorMsgType>;\n  }\n\n  checkAsync<T extends keyof DataType>(data: DataType) {\n    const checkResult: PlainObject = {};\n    const promises: Promise<CheckResult<ErrorMsgType | string>>[] = [];\n    const keys: string[] = [];\n\n    Object.keys(this.spec).forEach((key: string) => {\n      keys.push(key);\n      promises.push(this.checkForFieldAsync(key as T, data));\n    });\n\n    return Promise.all(promises).then(values => {\n      for (let i = 0; i < values.length; i += 1) {\n        checkResult[keys[i]] = values[i];\n      }\n      return checkResult as SchemaCheckResult<DataType, ErrorMsgType>;\n    });\n  }\n}\n\nexport function SchemaModel<DataType = PlainObject, ErrorMsgType = string>(\n  o: SchemaDeclaration<DataType, ErrorMsgType>\n) {\n  return new Schema<DataType, ErrorMsgType>(o);\n}\n\nSchemaModel.combine = function combine<DataType = any, ErrorMsgType = string>(\n  ...specs: Schema<any, ErrorMsgType>[]\n) {\n  return new Schema<DataType, ErrorMsgType>(\n    specs\n      .map(model => model.spec)\n      .reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {} as any)\n  );\n};\n"]},"metadata":{},"sourceType":"module"}