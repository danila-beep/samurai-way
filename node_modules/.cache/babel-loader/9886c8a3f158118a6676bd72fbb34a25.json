{"ast":null,"code":"import { useState, useEffect, useCallback } from 'react';\nimport uniq from 'lodash/uniq';\nimport remove from 'lodash/remove';\nimport slice from 'lodash/slice';\nimport { UNSAFE_flattenTree } from '../utils/treeUtils';\nimport { attachParent } from '../utils/attachParent';\n/**\n * Get all parents of a node\n * @param node\n */\n\nexport var getParents = function getParents(node) {\n  var parents = [];\n\n  if (!node.parent) {\n    return parents;\n  }\n\n  parents.push(node.parent);\n  parents = parents.concat(getParents(node.parent));\n  return parents;\n};\n/**\n * Check if any child nodes are selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeChildChecked = function isSomeChildChecked(node, value, itemKeys) {\n  var childrenKey = itemKeys.childrenKey,\n      valueKey = itemKeys.valueKey;\n\n  if (!node[childrenKey] || !value) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    var _child$childrenKey;\n\n    if (value.some(function (n) {\n      return n === child[valueKey];\n    })) {\n      return true;\n    }\n\n    if ((_child$childrenKey = child[childrenKey]) !== null && _child$childrenKey !== void 0 && _child$childrenKey.length) {\n      return isSomeChildChecked(child, value, itemKeys);\n    }\n\n    return false;\n  });\n};\n/**\n * Check if the parent is selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeParentChecked = function isSomeParentChecked(node, value, itemKeys) {\n  var valueKey = itemKeys.valueKey;\n\n  if (!value) {\n    return false;\n  }\n\n  if (value.some(function (n) {\n    return n === node[valueKey];\n  })) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isSomeParentChecked(node.parent, value, itemKeys);\n  }\n\n  return false;\n};\nexport var getOtherItemValuesByUnselectChild = function getOtherItemValuesByUnselectChild(itemNode, value, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var parentValues = [];\n  var itemValues = []; // Find the parent node of the current node by value\n\n  function findParent(item) {\n    parentValues.push(item[valueKey]);\n\n    if (value.some(function (v) {\n      return v === item[valueKey];\n    })) {\n      return item;\n    }\n\n    if (item.parent) {\n      var p = findParent(item.parent);\n\n      if (p) {\n        return p;\n      }\n    }\n\n    return null;\n  } // Get child nodes through parent node\n\n\n  function pushChildValue(item) {\n    if (!item[childrenKey]) {\n      return;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      // Determine whether it is a direct parent\n      if (parentValues.some(function (v) {\n        return v === n[valueKey];\n      }) && n[childrenKey]) {\n        pushChildValue(n);\n      } else if (n[valueKey] !== itemNode[valueKey]) {\n        itemValues.push(n[valueKey]);\n      }\n    });\n  }\n\n  var parent = findParent(itemNode);\n\n  if (!parent) {\n    return [];\n  }\n\n  pushChildValue(parent);\n  return itemValues;\n};\n/**\n * Remove the values of all children.\n */\n\nexport var removeAllChildrenValue = function removeAllChildrenValue(value, item, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var removedValue = [];\n\n  if (!item[childrenKey]) {\n    return;\n  }\n\n  item[childrenKey].forEach(function (n) {\n    removedValue = removedValue.concat(remove(value, function (v) {\n      return v === n[valueKey];\n    }));\n\n    if (n[childrenKey]) {\n      removeAllChildrenValue(value, n, itemKeys);\n    }\n  });\n  return removedValue;\n};\n/**\n * A hook to flatten tree structure data\n * @param data\n */\n\nexport function useFlattenData(data, itemKeys) {\n  var childrenKey = itemKeys.childrenKey;\n\n  var _useState = useState(UNSAFE_flattenTree(data, itemKeys.childrenKey)),\n      flattenData = _useState[0],\n      setFlattenData = _useState[1];\n\n  var addFlattenData = useCallback(function (children, parent) {\n    var nodes = children.map(function (child) {\n      return attachParent(child, parent);\n    });\n    parent[childrenKey] = nodes;\n    setFlattenData([].concat(flattenData, nodes));\n  }, [childrenKey, flattenData]);\n  useEffect(function () {\n    setFlattenData(UNSAFE_flattenTree(data, itemKeys.childrenKey));\n  }, [data, itemKeys.childrenKey]);\n  return {\n    addFlattenData: addFlattenData,\n    flattenData: flattenData\n  };\n}\n/**\n * A hook for column data\n * @param flattenData\n */\n\nexport function useColumnData(flattenData) {\n  // The columns displayed in the cascading panel.\n  var _useState2 = useState([flattenData.filter(function (item) {\n    return !item.parent;\n  })]),\n      columnData = _useState2[0],\n      setColumnData = _useState2[1];\n  /**\n   * Add a list of options to the cascading panel. Used for lazy loading options.\n   * @param column\n   * @param index The index of the current column.\n   */\n\n\n  function addColumn(column, index) {\n    setColumnData([].concat(slice(columnData, 0, index), [column]));\n  }\n  /**\n   * Remove subsequent columns of the specified column\n   * @param index\n   */\n\n\n  function removeColumnByIndex(index) {\n    setColumnData([].concat(slice(columnData, 0, index)));\n  }\n\n  function enforceUpdateColumnData(nextData) {\n    var nextFlattenData = UNSAFE_flattenTree(nextData);\n    setColumnData([nextFlattenData.filter(function (item) {\n      return !item.parent;\n    })]);\n  }\n\n  return {\n    columnData: columnData,\n    addColumn: addColumn,\n    removeColumnByIndex: removeColumnByIndex,\n    setColumnData: setColumnData,\n    enforceUpdateColumnData: enforceUpdateColumnData\n  };\n}\n/**\n * A hook that converts the value into a cascading value\n * @param props\n * @param flattenData\n */\n\nexport function useCascadeValue(props, flattenData) {\n  var valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      uncheckableItemValues = props.uncheckableItemValues,\n      cascade = props.cascade,\n      valueProp = props.value;\n  /**\n   * Get the values of all children\n   */\n\n  var getChildrenValue = useCallback(function (item) {\n    var values = [];\n\n    if (!item[childrenKey]) {\n      return values;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      if (uncheckableItemValues && !uncheckableItemValues.some(function (v) {\n        return v === n[valueKey];\n      })) {\n        values.push(n[valueKey]);\n      }\n\n      values = values.concat(getChildrenValue(n));\n    });\n    return values;\n  }, [childrenKey, uncheckableItemValues, valueKey]);\n  var splitValue = useCallback(function (item, checked, value) {\n    var itemValue = item[valueKey];\n    var childrenValue = getChildrenValue(item);\n    var parents = getParents(item);\n    var nextValue = [].concat(value);\n    var removedValue = [];\n\n    if (checked) {\n      nextValue.push(itemValue); // Delete all values under the current node\n\n      removedValue = removedValue.concat(removeAllChildrenValue(nextValue, item, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }) || []); // Traverse all ancestor nodes of the current node\n      // Then determine whether all the child nodes of these nodes are selected, and then they themselves must be selected\n\n      var _loop = function _loop(i) {\n        // Whether the parent node can be selected\n        var isCheckableParent = !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n          return v === parents[i][valueKey];\n        }));\n\n        if (isCheckableParent) {\n          var isCheckAll = parents[i][childrenKey] // Filter out options that are marked as not selectable\n          .filter(function (n) {\n            return !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n              return v === n[valueKey];\n            }));\n          }) // Check if all nodes are selected\n          .every(function (n) {\n            return nextValue.some(function (v) {\n              return v === n[valueKey];\n            });\n          });\n\n          if (isCheckAll) {\n            // Add parent node value\n            nextValue.push(parents[i][valueKey]); // Delete all values under the parent node\n\n            removedValue = removedValue.concat(removeAllChildrenValue(nextValue, parents[i], {\n              valueKey: valueKey,\n              childrenKey: childrenKey\n            }) || []);\n          }\n        }\n      };\n\n      for (var i = 0; i < parents.length; i++) {\n        _loop(i);\n      }\n    } else {\n      var tempValue = childrenValue.concat(parents.map(function (item) {\n        return item[valueKey];\n      }));\n      nextValue = nextValue.concat(getOtherItemValuesByUnselectChild(item, nextValue, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      })); // Delete related child and parent nodes\n\n      removedValue = remove(nextValue, function (v) {\n        // Delete yourself\n        if (v === itemValue) {\n          return true;\n        }\n\n        return tempValue.some(function (n) {\n          return n === v;\n        });\n      });\n    }\n\n    var uniqValue = uniq(nextValue);\n    var uniqRemovedValue = uniq(removedValue);\n    return {\n      value: uniqValue,\n      removedValue: uniqRemovedValue\n    };\n  }, [valueKey, childrenKey, uncheckableItemValues, getChildrenValue]);\n  var transformValue = useCallback(function (value) {\n    if (value === void 0) {\n      value = [];\n    }\n\n    if (!cascade) {\n      return value;\n    }\n\n    var tempRemovedValue = [];\n    var nextValue = [];\n\n    var _loop2 = function _loop2(i) {\n      // If the value in the current value is already in the deleted list, it will not be processed\n      if (tempRemovedValue.some(function (v) {\n        return v === value[i];\n      })) {\n        return \"continue\";\n      }\n\n      var item = flattenData.find(function (v) {\n        return v[valueKey] === value[i];\n      });\n\n      if (!item) {\n        return \"continue\";\n      }\n\n      var sv = splitValue(item, true, value);\n      tempRemovedValue = uniq(tempRemovedValue.concat(sv.removedValue)); // Get all relevant values\n\n      nextValue = uniq(nextValue.concat(sv.value));\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret = _loop2(i);\n\n      if (_ret === \"continue\") continue;\n    } // Finally traverse all nextValue, and delete if its parent node is also nextValue\n\n\n    return nextValue.filter(function (v) {\n      var item = flattenData.find(function (n) {\n        return n[valueKey] === v;\n      });\n\n      if (item !== null && item !== void 0 && item.parent && nextValue.some(function (v) {\n        return v === item.parent && item.parent[valueKey];\n      })) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [cascade, flattenData, splitValue, valueKey]);\n\n  var _useState3 = useState(transformValue(valueProp) || []),\n      value = _useState3[0],\n      setValue = _useState3[1];\n\n  useEffect(function () {\n    // Update value when valueProp is updated.\n    setValue(transformValue(valueProp) || []);\n  }, [transformValue, valueProp]);\n  return {\n    value: value,\n    setValue: setValue,\n    splitValue: splitValue\n  };\n}","map":{"version":3,"sources":["/Users/danilnagovicyn/Desktop/reactprojects/Incubator/Samurai_way/samurai-way/node_modules/rsuite/esm/MultiCascader/utils.js"],"names":["useState","useEffect","useCallback","uniq","remove","slice","UNSAFE_flattenTree","attachParent","getParents","node","parents","parent","push","concat","isSomeChildChecked","value","itemKeys","childrenKey","valueKey","some","child","_child$childrenKey","n","length","isSomeParentChecked","getOtherItemValuesByUnselectChild","itemNode","parentValues","itemValues","findParent","item","v","p","pushChildValue","forEach","removeAllChildrenValue","removedValue","useFlattenData","data","_useState","flattenData","setFlattenData","addFlattenData","children","nodes","map","useColumnData","_useState2","filter","columnData","setColumnData","addColumn","column","index","removeColumnByIndex","enforceUpdateColumnData","nextData","nextFlattenData","useCascadeValue","props","uncheckableItemValues","cascade","valueProp","getChildrenValue","values","splitValue","checked","itemValue","childrenValue","nextValue","_loop","i","isCheckableParent","isCheckAll","every","tempValue","uniqValue","uniqRemovedValue","transformValue","tempRemovedValue","_loop2","find","sv","_ret","_useState3","setValue"],"mappings":"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","sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport uniq from 'lodash/uniq';\nimport remove from 'lodash/remove';\nimport slice from 'lodash/slice';\nimport { UNSAFE_flattenTree } from '../utils/treeUtils';\nimport { attachParent } from '../utils/attachParent';\n\n/**\n * Get all parents of a node\n * @param node\n */\nexport var getParents = function getParents(node) {\n  var parents = [];\n\n  if (!node.parent) {\n    return parents;\n  }\n\n  parents.push(node.parent);\n  parents = parents.concat(getParents(node.parent));\n  return parents;\n};\n/**\n * Check if any child nodes are selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeChildChecked = function isSomeChildChecked(node, value, itemKeys) {\n  var childrenKey = itemKeys.childrenKey,\n      valueKey = itemKeys.valueKey;\n\n  if (!node[childrenKey] || !value) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    var _child$childrenKey;\n\n    if (value.some(function (n) {\n      return n === child[valueKey];\n    })) {\n      return true;\n    }\n\n    if ((_child$childrenKey = child[childrenKey]) !== null && _child$childrenKey !== void 0 && _child$childrenKey.length) {\n      return isSomeChildChecked(child, value, itemKeys);\n    }\n\n    return false;\n  });\n};\n/**\n * Check if the parent is selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeParentChecked = function isSomeParentChecked(node, value, itemKeys) {\n  var valueKey = itemKeys.valueKey;\n\n  if (!value) {\n    return false;\n  }\n\n  if (value.some(function (n) {\n    return n === node[valueKey];\n  })) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isSomeParentChecked(node.parent, value, itemKeys);\n  }\n\n  return false;\n};\nexport var getOtherItemValuesByUnselectChild = function getOtherItemValuesByUnselectChild(itemNode, value, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var parentValues = [];\n  var itemValues = []; // Find the parent node of the current node by value\n\n  function findParent(item) {\n    parentValues.push(item[valueKey]);\n\n    if (value.some(function (v) {\n      return v === item[valueKey];\n    })) {\n      return item;\n    }\n\n    if (item.parent) {\n      var p = findParent(item.parent);\n\n      if (p) {\n        return p;\n      }\n    }\n\n    return null;\n  } // Get child nodes through parent node\n\n\n  function pushChildValue(item) {\n    if (!item[childrenKey]) {\n      return;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      // Determine whether it is a direct parent\n      if (parentValues.some(function (v) {\n        return v === n[valueKey];\n      }) && n[childrenKey]) {\n        pushChildValue(n);\n      } else if (n[valueKey] !== itemNode[valueKey]) {\n        itemValues.push(n[valueKey]);\n      }\n    });\n  }\n\n  var parent = findParent(itemNode);\n\n  if (!parent) {\n    return [];\n  }\n\n  pushChildValue(parent);\n  return itemValues;\n};\n/**\n * Remove the values of all children.\n */\n\nexport var removeAllChildrenValue = function removeAllChildrenValue(value, item, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var removedValue = [];\n\n  if (!item[childrenKey]) {\n    return;\n  }\n\n  item[childrenKey].forEach(function (n) {\n    removedValue = removedValue.concat(remove(value, function (v) {\n      return v === n[valueKey];\n    }));\n\n    if (n[childrenKey]) {\n      removeAllChildrenValue(value, n, itemKeys);\n    }\n  });\n  return removedValue;\n};\n/**\n * A hook to flatten tree structure data\n * @param data\n */\n\nexport function useFlattenData(data, itemKeys) {\n  var childrenKey = itemKeys.childrenKey;\n\n  var _useState = useState(UNSAFE_flattenTree(data, itemKeys.childrenKey)),\n      flattenData = _useState[0],\n      setFlattenData = _useState[1];\n\n  var addFlattenData = useCallback(function (children, parent) {\n    var nodes = children.map(function (child) {\n      return attachParent(child, parent);\n    });\n    parent[childrenKey] = nodes;\n    setFlattenData([].concat(flattenData, nodes));\n  }, [childrenKey, flattenData]);\n  useEffect(function () {\n    setFlattenData(UNSAFE_flattenTree(data, itemKeys.childrenKey));\n  }, [data, itemKeys.childrenKey]);\n  return {\n    addFlattenData: addFlattenData,\n    flattenData: flattenData\n  };\n}\n/**\n * A hook for column data\n * @param flattenData\n */\n\nexport function useColumnData(flattenData) {\n  // The columns displayed in the cascading panel.\n  var _useState2 = useState([flattenData.filter(function (item) {\n    return !item.parent;\n  })]),\n      columnData = _useState2[0],\n      setColumnData = _useState2[1];\n  /**\n   * Add a list of options to the cascading panel. Used for lazy loading options.\n   * @param column\n   * @param index The index of the current column.\n   */\n\n\n  function addColumn(column, index) {\n    setColumnData([].concat(slice(columnData, 0, index), [column]));\n  }\n  /**\n   * Remove subsequent columns of the specified column\n   * @param index\n   */\n\n\n  function removeColumnByIndex(index) {\n    setColumnData([].concat(slice(columnData, 0, index)));\n  }\n\n  function enforceUpdateColumnData(nextData) {\n    var nextFlattenData = UNSAFE_flattenTree(nextData);\n    setColumnData([nextFlattenData.filter(function (item) {\n      return !item.parent;\n    })]);\n  }\n\n  return {\n    columnData: columnData,\n    addColumn: addColumn,\n    removeColumnByIndex: removeColumnByIndex,\n    setColumnData: setColumnData,\n    enforceUpdateColumnData: enforceUpdateColumnData\n  };\n}\n/**\n * A hook that converts the value into a cascading value\n * @param props\n * @param flattenData\n */\n\nexport function useCascadeValue(props, flattenData) {\n  var valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      uncheckableItemValues = props.uncheckableItemValues,\n      cascade = props.cascade,\n      valueProp = props.value;\n  /**\n   * Get the values of all children\n   */\n\n  var getChildrenValue = useCallback(function (item) {\n    var values = [];\n\n    if (!item[childrenKey]) {\n      return values;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      if (uncheckableItemValues && !uncheckableItemValues.some(function (v) {\n        return v === n[valueKey];\n      })) {\n        values.push(n[valueKey]);\n      }\n\n      values = values.concat(getChildrenValue(n));\n    });\n    return values;\n  }, [childrenKey, uncheckableItemValues, valueKey]);\n  var splitValue = useCallback(function (item, checked, value) {\n    var itemValue = item[valueKey];\n    var childrenValue = getChildrenValue(item);\n    var parents = getParents(item);\n    var nextValue = [].concat(value);\n    var removedValue = [];\n\n    if (checked) {\n      nextValue.push(itemValue); // Delete all values under the current node\n\n      removedValue = removedValue.concat(removeAllChildrenValue(nextValue, item, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }) || []); // Traverse all ancestor nodes of the current node\n      // Then determine whether all the child nodes of these nodes are selected, and then they themselves must be selected\n\n      var _loop = function _loop(i) {\n        // Whether the parent node can be selected\n        var isCheckableParent = !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n          return v === parents[i][valueKey];\n        }));\n\n        if (isCheckableParent) {\n          var isCheckAll = parents[i][childrenKey] // Filter out options that are marked as not selectable\n          .filter(function (n) {\n            return !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n              return v === n[valueKey];\n            }));\n          }) // Check if all nodes are selected\n          .every(function (n) {\n            return nextValue.some(function (v) {\n              return v === n[valueKey];\n            });\n          });\n\n          if (isCheckAll) {\n            // Add parent node value\n            nextValue.push(parents[i][valueKey]); // Delete all values under the parent node\n\n            removedValue = removedValue.concat(removeAllChildrenValue(nextValue, parents[i], {\n              valueKey: valueKey,\n              childrenKey: childrenKey\n            }) || []);\n          }\n        }\n      };\n\n      for (var i = 0; i < parents.length; i++) {\n        _loop(i);\n      }\n    } else {\n      var tempValue = childrenValue.concat(parents.map(function (item) {\n        return item[valueKey];\n      }));\n      nextValue = nextValue.concat(getOtherItemValuesByUnselectChild(item, nextValue, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      })); // Delete related child and parent nodes\n\n      removedValue = remove(nextValue, function (v) {\n        // Delete yourself\n        if (v === itemValue) {\n          return true;\n        }\n\n        return tempValue.some(function (n) {\n          return n === v;\n        });\n      });\n    }\n\n    var uniqValue = uniq(nextValue);\n    var uniqRemovedValue = uniq(removedValue);\n    return {\n      value: uniqValue,\n      removedValue: uniqRemovedValue\n    };\n  }, [valueKey, childrenKey, uncheckableItemValues, getChildrenValue]);\n  var transformValue = useCallback(function (value) {\n    if (value === void 0) {\n      value = [];\n    }\n\n    if (!cascade) {\n      return value;\n    }\n\n    var tempRemovedValue = [];\n    var nextValue = [];\n\n    var _loop2 = function _loop2(i) {\n      // If the value in the current value is already in the deleted list, it will not be processed\n      if (tempRemovedValue.some(function (v) {\n        return v === value[i];\n      })) {\n        return \"continue\";\n      }\n\n      var item = flattenData.find(function (v) {\n        return v[valueKey] === value[i];\n      });\n\n      if (!item) {\n        return \"continue\";\n      }\n\n      var sv = splitValue(item, true, value);\n      tempRemovedValue = uniq(tempRemovedValue.concat(sv.removedValue)); // Get all relevant values\n\n      nextValue = uniq(nextValue.concat(sv.value));\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret = _loop2(i);\n\n      if (_ret === \"continue\") continue;\n    } // Finally traverse all nextValue, and delete if its parent node is also nextValue\n\n\n    return nextValue.filter(function (v) {\n      var item = flattenData.find(function (n) {\n        return n[valueKey] === v;\n      });\n\n      if (item !== null && item !== void 0 && item.parent && nextValue.some(function (v) {\n        return v === item.parent && item.parent[valueKey];\n      })) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [cascade, flattenData, splitValue, valueKey]);\n\n  var _useState3 = useState(transformValue(valueProp) || []),\n      value = _useState3[0],\n      setValue = _useState3[1];\n\n  useEffect(function () {\n    // Update value when valueProp is updated.\n    setValue(transformValue(valueProp) || []);\n  }, [transformValue, valueProp]);\n  return {\n    value: value,\n    setValue: setValue,\n    splitValue: splitValue\n  };\n}"]},"metadata":{},"sourceType":"module"}