{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\nimport { attachParent } from './attachParent'; // gap of tree node\n\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n *\n * @deprecated This {@link UNSAFE_flattenTree} function is considered unsafe because it mutates `tree` argument in-place\n *             Use {@link flattenTree} instead.\n */\n\nexport function UNSAFE_flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      flattenData.push(attachParent(node, parent));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\nexport var WalkTreeStrategy;\n\n(function (WalkTreeStrategy) {\n  WalkTreeStrategy[WalkTreeStrategy[\"DFS\"] = 0] = \"DFS\";\n  WalkTreeStrategy[WalkTreeStrategy[\"BFS\"] = 1] = \"BFS\";\n})(WalkTreeStrategy || (WalkTreeStrategy = {}));\n\nexport function flattenTree(rootNodes, getChildren, walkStrategy) {\n  if (walkStrategy === void 0) {\n    walkStrategy = WalkTreeStrategy.BFS;\n  }\n\n  var result = [];\n\n  if (walkStrategy === WalkTreeStrategy.BFS) {\n    walkTreeBfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  } else if (walkStrategy === WalkTreeStrategy.DFS) {\n    walkTreeDfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  }\n\n  return result;\n}\nexport function walkTreeBfs(rootNodes, getChildren, callback) {\n  for (var queue = [].concat(rootNodes); queue.length > 0;) {\n    var _node = queue.shift();\n\n    callback(_node);\n    var children = getChildren(_node);\n\n    if (children) {\n      queue.push.apply(queue, children);\n    }\n  }\n}\nexport function walkTreeDfs(rootNodes, getChildren, callback) {\n  for (var _iterator = _createForOfIteratorHelperLoose(rootNodes), _step; !(_step = _iterator()).done;) {\n    var _node2 = _step.value;\n    callback(_node2);\n    var children = getChildren(_node2);\n\n    if (children) {\n      walkTreeDfs(children, getChildren, callback);\n    }\n  }\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return UNSAFE_flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node3 = findNode(_item3.children);\n\n        if (_node3) {\n          return _node3;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\n\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\n\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node) {\n      var _extends2;\n\n      var value = node[valueKey];\n      /**\n       * because the value of the node's type is string or number,\n       * so it can used as the key of the object directly\n       * to avoid number value is converted to string. 1 and '1' will be convert to '1'\n       *  we used `String_` or `Number_` prefix\n       */\n\n      var refKey = getNodeFormattedRefKey(value);\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues; // Reset values to false\n\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return UNSAFE_flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data);\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\n\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\n\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  } // layer start from 1\n\n\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}\n/**\n * according to the value type to get the formatted valueKey of the node\n * @param value\n * @returns\n */\n\nexport function getNodeFormattedRefKey(value) {\n  return \"\" + (typeof value === 'number' ? 'Number_' : 'String_') + value;\n}\n/**\n * create drag preview when tree node start drag\n * @param name\n * @param className\n * @returns\n */\n\nexport function createDragPreview(name, className) {\n  var dragPreview = document.createElement('div');\n  dragPreview.id = 'rs-tree-drag-preview';\n  dragPreview.innerHTML = name;\n  dragPreview.classList.add(className);\n  document.body.appendChild(dragPreview);\n  return dragPreview;\n}\n/**\n * remove drag preview when tree node drop\n */\n\nexport function removeDragPreview() {\n  var _dragPreview$parentNo, _dragPreview$parentNo2;\n\n  var dragPreview = document.getElementById('rs-tree-drag-preview');\n  dragPreview === null || dragPreview === void 0 ? void 0 : (_dragPreview$parentNo = dragPreview.parentNode) === null || _dragPreview$parentNo === void 0 ? void 0 : (_dragPreview$parentNo2 = _dragPreview$parentNo.removeChild) === null || _dragPreview$parentNo2 === void 0 ? void 0 : _dragPreview$parentNo2.call(_dragPreview$parentNo, dragPreview);\n}\nexport function stringifyTreeNodeLabel(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes2 = reactToString(label);\n\n    return _nodes2.join('');\n  }\n\n  return '';\n}\n/**\n * Returns a WeakMap that maps each item in `items` to its parent\n * indicated by `getChildren` function\n */\n\nexport function getParentMap(items, getChildren) {\n  var map = new WeakMap();\n\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item5 = queue.shift();\n\n    var children = getChildren(_item5);\n\n    if (children) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {\n        var child = _step2.value;\n        map.set(child, _item5);\n        queue.push(child);\n      }\n    }\n  }\n\n  return map;\n}\n/**\n * Returns a Map that maps each item's \"key\", indicated by `getKey` function,\n * to its parent indicated by `getChildren` function\n *\n * NOTICE:\n * Using this function is discouraged.\n * Use {@link getParentMap} whenever possible.\n */\n\nexport function getKeyParentMap(items, getKey, getChildren) {\n  var map = new Map();\n\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item6 = queue.shift();\n\n    var children = getChildren(_item6);\n\n    if (children) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {\n        var child = _step3.value;\n        map.set(getKey(child), _item6);\n        queue.push(child);\n      }\n    }\n  }\n\n  return map;\n}\n/**\n * Returns an array indicating the hierarchy path from root towards `target` item\n */\n\nexport function getPathTowardsItem(target, getParent) {\n  if (!target) return [];\n  var path = [target];\n\n  for (var parent = getParent(target); !!parent; parent = getParent(parent)) {\n    path.unshift(parent);\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/danilnagovicyn/Desktop/reactprojects/Incubator/Samurai_way/samurai-way/node_modules/rsuite/esm/utils/treeUtils.js"],"names":["_extends","_isEmpty","_clone","_isNil","_isArray","_omit","_isUndefined","_intersection","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","React","useRef","useState","useEffect","useCallback","shallowEqualArray","getNodeCheckState","TREE_NODE_DROP_POSITION","shallowEqual","shouldDisplay","reactToString","TREE_NODE_PADDING","TREE_NODE_ROOT_PADDING","attachParent","TREE_NODE_GAP","shouldShowNodeByParentExpanded","expandItemValues","parentKeys","intersectionKeys","UNSAFE_flattenTree","tree","childrenKey","executor","flattenData","traverse","data","parent","forEach","item","index","node","push","WalkTreeStrategy","flattenTree","rootNodes","getChildren","walkStrategy","BFS","result","walkTreeBfs","DFS","walkTreeDfs","callback","queue","concat","_node","shift","children","apply","_iterator","_step","_node2","getNodeParents","parentKey","valueKey","parents","getNodeParentKeys","nodes","_node$parent","refKey","_node$parent2","hasVisibleChildren","some","child","visible","compareArray","a","b","getDefaultExpandItemValues","props","defaultExpandAll","_props$defaultExpandI","defaultExpandItemValues","filter","map","getExpandItemValues","getDragNodeKeys","dragNode","dragNodeKeys","calDropNodePosition","event","treeNodeElement","clientY","_treeNodeElement$getB","getBoundingClientRect","top","bottom","gap","DRAG_OVER_BOTTOM","DRAG_OVER_TOP","DRAG_OVER","removeDragNode","params","_ref","items","_index","_item","splice","createUpdateTreeDataFunction","_ref2","dropNode","dropNodePosition","cloneDragNode","updateTree","_index2","_item2","findNodeOfTree","check","findNode","_item3","_node3","undefined","filterNodesOfTree","findNodes","nextNodes","nextChildren","_item4","getFocusableItems","filteredData","isSearching","disabledItemValues","loop","disabled","disabledItem","expand","includes","getActiveIndex","focusItemValue","focusItems","activeIndex","getActiveItem","flattenNodes","nodeData","activeNode","values","find","getElementByDataKey","dataKey","treeNodesRefs","selector","ele","Element","querySelector","focusTreeNode","treeNodeRefs","_node$focus","focus","focusNextItem","_ref3","focusableItems","nextIndex","nextFocusItemValue","focusPreviousItem","_ref4","prevIndex","prevFocusItemValue","leftArrowHandler","_ref5","focusItem","onExpand","onFocusItem","rightArrowHandler","_ref6","getScrollToIndex","findIndex","getExpandWhenSearching","searchKeyword","getTreeActiveNode","toggleExpand","_ref7","isExpand","newExpandItemValues","Set","add","delete","getTreeNodeTitle","label","isValidElement","_nodes","join","getChildrenByFlattenNodes","_item$parent","uncheckable","useTreeDrag","_useState","dragOverNodeKey","setDragOverNodeKey","_useState2","setDragNodeKeys","_useState3","setDropNodePosition","setDragNode","current","useFlattenTreeData","_ref8","labelKey","_ref8$uncheckableItem","uncheckableItemValues","_useState4","create","dispatch","forceUpdate","flattenTreeData","treeData","layer","_extends2","getNodeFormattedRefKey","serializeListOnlyParent","key","list","keys","currentNode","parentNode","checkAll","unSerializeList","_ref9","_ref9$value","cascade","uncheckableValue","formatVirtualizedTreeData","options","formatted","curNode","checkState","hasChildren","useTreeNodeRefs","saveTreeNodeRef","ref","useTreeSearch","searchBy","filterVisibleData","setVisible","_useState5","searchKeywordState","setSearchKeyword","_useState6","setFilteredData","handleSetFilteredData","handleSearch","useGetTreeNodeChildren","_useState7","loadingNodeValues","setLoadingNodeValues","_useState8","setData","concatChildren","treeNode","newData","loadChildren","prev","Promise","then","res","focusToActiveTreeNode","_ref10","_activeItem$focus","virtualized","container","formattedNodes","_list$scrollToRow","scrollIndex","scrollToRow","activeItem","getTreeNodeIndent","rtl","absolute","_ref12","offset","_ref11","createDragPreview","className","dragPreview","document","createElement","id","innerHTML","classList","body","appendChild","removeDragPreview","_dragPreview$parentNo","_dragPreview$parentNo2","getElementById","removeChild","stringifyTreeNodeLabel","_nodes2","getParentMap","WeakMap","_item5","_iterator2","_step2","set","getKeyParentMap","getKey","Map","_item6","_iterator3","_step3","getPathTowardsItem","target","getParent","path","unshift"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\nimport { attachParent } from './attachParent';\n// gap of tree node\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n *\n * @deprecated This {@link UNSAFE_flattenTree} function is considered unsafe because it mutates `tree` argument in-place\n *             Use {@link flattenTree} instead.\n */\n\nexport function UNSAFE_flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      flattenData.push(attachParent(node, parent));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\nexport var WalkTreeStrategy;\n\n(function (WalkTreeStrategy) {\n  WalkTreeStrategy[WalkTreeStrategy[\"DFS\"] = 0] = \"DFS\";\n  WalkTreeStrategy[WalkTreeStrategy[\"BFS\"] = 1] = \"BFS\";\n})(WalkTreeStrategy || (WalkTreeStrategy = {}));\n\nexport function flattenTree(rootNodes, getChildren, walkStrategy) {\n  if (walkStrategy === void 0) {\n    walkStrategy = WalkTreeStrategy.BFS;\n  }\n\n  var result = [];\n\n  if (walkStrategy === WalkTreeStrategy.BFS) {\n    walkTreeBfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  } else if (walkStrategy === WalkTreeStrategy.DFS) {\n    walkTreeDfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  }\n\n  return result;\n}\nexport function walkTreeBfs(rootNodes, getChildren, callback) {\n  for (var queue = [].concat(rootNodes); queue.length > 0;) {\n    var _node = queue.shift();\n\n    callback(_node);\n    var children = getChildren(_node);\n\n    if (children) {\n      queue.push.apply(queue, children);\n    }\n  }\n}\nexport function walkTreeDfs(rootNodes, getChildren, callback) {\n  for (var _iterator = _createForOfIteratorHelperLoose(rootNodes), _step; !(_step = _iterator()).done;) {\n    var _node2 = _step.value;\n    callback(_node2);\n    var children = getChildren(_node2);\n\n    if (children) {\n      walkTreeDfs(children, getChildren, callback);\n    }\n  }\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return UNSAFE_flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node3 = findNode(_item3.children);\n\n        if (_node3) {\n          return _node3;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n\n/**\n * focus next item with keyboard\n * @param param\n */\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n\n/**\n * hooks for flatten tree structure\n * @param param0\n */\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node) {\n      var _extends2;\n\n      var value = node[valueKey];\n      /**\n       * because the value of the node's type is string or number,\n       * so it can used as the key of the object directly\n       * to avoid number value is converted to string. 1 and '1' will be convert to '1'\n       *  we used `String_` or `Number_` prefix\n       */\n\n      var refKey = getNodeFormattedRefKey(value);\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues;\n    // Reset values to false\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return UNSAFE_flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data);\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n\n/**\n * A hook that handles tree search filter options\n * @param props\n */\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n\n/**\n * Focus to active tree node.\n * @param param0\n */\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  }\n\n  // layer start from 1\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}\n/**\n * according to the value type to get the formatted valueKey of the node\n * @param value\n * @returns\n */\n\nexport function getNodeFormattedRefKey(value) {\n  return \"\" + (typeof value === 'number' ? 'Number_' : 'String_') + value;\n}\n/**\n * create drag preview when tree node start drag\n * @param name\n * @param className\n * @returns\n */\n\nexport function createDragPreview(name, className) {\n  var dragPreview = document.createElement('div');\n  dragPreview.id = 'rs-tree-drag-preview';\n  dragPreview.innerHTML = name;\n  dragPreview.classList.add(className);\n  document.body.appendChild(dragPreview);\n  return dragPreview;\n}\n/**\n * remove drag preview when tree node drop\n */\n\nexport function removeDragPreview() {\n  var _dragPreview$parentNo, _dragPreview$parentNo2;\n\n  var dragPreview = document.getElementById('rs-tree-drag-preview');\n  dragPreview === null || dragPreview === void 0 ? void 0 : (_dragPreview$parentNo = dragPreview.parentNode) === null || _dragPreview$parentNo === void 0 ? void 0 : (_dragPreview$parentNo2 = _dragPreview$parentNo.removeChild) === null || _dragPreview$parentNo2 === void 0 ? void 0 : _dragPreview$parentNo2.call(_dragPreview$parentNo, dragPreview);\n}\nexport function stringifyTreeNodeLabel(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes2 = reactToString(label);\n\n    return _nodes2.join('');\n  }\n\n  return '';\n}\n/**\n * Returns a WeakMap that maps each item in `items` to its parent\n * indicated by `getChildren` function\n */\n\nexport function getParentMap(items, getChildren) {\n  var map = new WeakMap();\n\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item5 = queue.shift();\n\n    var children = getChildren(_item5);\n\n    if (children) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {\n        var child = _step2.value;\n        map.set(child, _item5);\n        queue.push(child);\n      }\n    }\n  }\n\n  return map;\n}\n/**\n * Returns a Map that maps each item's \"key\", indicated by `getKey` function,\n * to its parent indicated by `getChildren` function\n *\n * NOTICE:\n * Using this function is discouraged.\n * Use {@link getParentMap} whenever possible.\n */\n\nexport function getKeyParentMap(items, getKey, getChildren) {\n  var map = new Map();\n\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item6 = queue.shift();\n\n    var children = getChildren(_item6);\n\n    if (children) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {\n        var child = _step3.value;\n        map.set(getKey(child), _item6);\n        queue.push(child);\n      }\n    }\n  }\n\n  return map;\n}\n/**\n * Returns an array indicating the hierarchy path from root towards `target` item\n */\n\nexport function getPathTowardsItem(target, getParent) {\n  if (!target) return [];\n  var path = [target];\n\n  for (var parent = getParent(target); !!parent; parent = getParent(parent)) {\n    path.unshift(parent);\n  }\n\n  return path;\n}"]},"metadata":{},"sourceType":"module"}