{"ast":null,"code":"import _groupBy from \"lodash/groupBy\";\nimport { WalkTreeStrategy, flattenTree } from '../utils/treeUtils';\nvar hasSymbol = typeof Symbol === 'function';\nexport var KEY_GROUP = hasSymbol ? Symbol('_$grouped') : '_$grouped';\nexport var KEY_GROUP_TITLE = 'groupTitle';\nexport function getDataGroupBy(data, key, sort) {\n  var groupMap = _groupBy(data, key);\n\n  var isSort = typeof sort === 'function';\n  var groups = Object.entries(groupMap).map(function (_ref) {\n    var _ref2;\n\n    var groupTitle = _ref[0],\n        children = _ref[1];\n    return _ref2 = {\n      children: isSort ? children.sort(sort(false)) : children\n    }, _ref2[KEY_GROUP_TITLE] = groupTitle, _ref2[KEY_GROUP] = true, _ref2;\n  });\n\n  if (isSort) {\n    groups.sort(sort(true));\n  } // Use DFS traverse\n  // Because I want the result to be [group, child, child, group, child, child]\n  // rather than [group, group, child, child, child, child]\n\n\n  return flattenTree(groups, function (group) {\n    return group.children;\n  }, WalkTreeStrategy.DFS);\n}","map":{"version":3,"sources":["/Users/danilnagovicyn/Desktop/reactprojects/Incubator/Samurai_way/samurai-way/node_modules/rsuite/esm/utils/getDataGroupBy.js"],"names":["_groupBy","WalkTreeStrategy","flattenTree","hasSymbol","Symbol","KEY_GROUP","KEY_GROUP_TITLE","getDataGroupBy","data","key","sort","groupMap","isSort","groups","Object","entries","map","_ref","_ref2","groupTitle","children","group","DFS"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,gBAArB;AACA,SAASC,gBAAT,EAA2BC,WAA3B,QAA8C,oBAA9C;AACA,IAAIC,SAAS,GAAG,OAAOC,MAAP,KAAkB,UAAlC;AACA,OAAO,IAAIC,SAAS,GAAGF,SAAS,GAAGC,MAAM,CAAC,WAAD,CAAT,GAAyB,WAAlD;AACP,OAAO,IAAIE,eAAe,GAAG,YAAtB;AACP,OAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AAC9C,MAAIC,QAAQ,GAAGX,QAAQ,CAACQ,IAAD,EAAOC,GAAP,CAAvB;;AAEA,MAAIG,MAAM,GAAG,OAAOF,IAAP,KAAgB,UAA7B;AACA,MAAIG,MAAM,GAAGC,MAAM,CAACC,OAAP,CAAeJ,QAAf,EAAyBK,GAAzB,CAA6B,UAAUC,IAAV,EAAgB;AACxD,QAAIC,KAAJ;;AAEA,QAAIC,UAAU,GAAGF,IAAI,CAAC,CAAD,CAArB;AAAA,QACIG,QAAQ,GAAGH,IAAI,CAAC,CAAD,CADnB;AAEA,WAAOC,KAAK,GAAG;AACbE,MAAAA,QAAQ,EAAER,MAAM,GAAGQ,QAAQ,CAACV,IAAT,CAAcA,IAAI,CAAC,KAAD,CAAlB,CAAH,GAAgCU;AADnC,KAAR,EAEJF,KAAK,CAACZ,eAAD,CAAL,GAAyBa,UAFrB,EAEiCD,KAAK,CAACb,SAAD,CAAL,GAAmB,IAFpD,EAE0Da,KAFjE;AAGD,GARY,CAAb;;AAUA,MAAIN,MAAJ,EAAY;AACVC,IAAAA,MAAM,CAACH,IAAP,CAAYA,IAAI,CAAC,IAAD,CAAhB;AACD,GAhB6C,CAgB5C;AACF;AACA;;;AAGA,SAAOR,WAAW,CAACW,MAAD,EAAS,UAAUQ,KAAV,EAAiB;AAC1C,WAAOA,KAAK,CAACD,QAAb;AACD,GAFiB,EAEfnB,gBAAgB,CAACqB,GAFF,CAAlB;AAGD","sourcesContent":["import _groupBy from \"lodash/groupBy\";\nimport { WalkTreeStrategy, flattenTree } from '../utils/treeUtils';\nvar hasSymbol = typeof Symbol === 'function';\nexport var KEY_GROUP = hasSymbol ? Symbol('_$grouped') : '_$grouped';\nexport var KEY_GROUP_TITLE = 'groupTitle';\nexport function getDataGroupBy(data, key, sort) {\n  var groupMap = _groupBy(data, key);\n\n  var isSort = typeof sort === 'function';\n  var groups = Object.entries(groupMap).map(function (_ref) {\n    var _ref2;\n\n    var groupTitle = _ref[0],\n        children = _ref[1];\n    return _ref2 = {\n      children: isSort ? children.sort(sort(false)) : children\n    }, _ref2[KEY_GROUP_TITLE] = groupTitle, _ref2[KEY_GROUP] = true, _ref2;\n  });\n\n  if (isSort) {\n    groups.sort(sort(true));\n  } // Use DFS traverse\n  // Because I want the result to be [group, child, child, group, child, child]\n  // rather than [group, group, child, child, child, child]\n\n\n  return flattenTree(groups, function (group) {\n    return group.children;\n  }, WalkTreeStrategy.DFS);\n}"]},"metadata":{},"sourceType":"module"}